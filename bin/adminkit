#!/usr/bin/env php
<?php

declare(strict_types=1);

/*
 * AdminKit Console Application v1.0.7
 * 
 * Enterprise admin panel CLI tool with comprehensive backup system,
 * advanced configuration management, and enhanced development tools.
 */

// Find autoloader
$autoloaderPaths = [
    __DIR__ . '/../vendor/autoload.php',      // Package development
    __DIR__ . '/../../../autoload.php',      // Package installed in project
    __DIR__ . '/../../../../autoload.php',   // Package installed globally
];

$autoloaderFound = false;
foreach ($autoloaderPaths as $path) {
    if (file_exists($path)) {
        require_once $path;
        $autoloaderFound = true;
        break;
    }
}

if (!$autoloaderFound) {
    fwrite(STDERR, "Error: Could not find Composer autoloader.\n");
    fwrite(STDERR, "Please run 'composer install' first.\n");
    exit(1);
}

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Console\Question\Question;
use Symfony\Component\Console\Question\ChoiceQuestion;

/**
 * Helper function to get database connection
 */
function getDatabase(): ?PDO
{
    $env = loadEnvironment();
    
    $host = $env['DB_HOST'] ?? 'localhost';
    $port = $env['DB_PORT'] ?? '3306';
    $database = $env['DB_DATABASE'] ?? '';
    $username = $env['DB_USERNAME'] ?? 'root';
    $password = $env['DB_PASSWORD'] ?? '';
    $driver = $env['DB_CONNECTION'] ?? 'mysql';
    
    if (empty($database)) {
        return null;
    }
    
    try {
        $dsn = sprintf('%s:host=%s;port=%s;dbname=%s;charset=utf8mb4',
            $driver, $host, $port, $database
        );
        
        return new PDO($dsn, $username, $password, [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
        ]);
    } catch (Exception $e) {
        return null;
    }
}

/**
 * Enhanced Environment loader
 */
function loadEnvironment(): array
{
    $envFile = getcwd() . '/.env';
    $env = [];
    
    if (file_exists($envFile)) {
        $lines = file($envFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
        foreach ($lines as $line) {
            if (strpos($line, '=') !== false && !str_starts_with($line, '#')) {
                list($key, $value) = explode('=', $line, 2);
                $env[trim($key)] = trim($value, '"\'');
            }
        }
    }
    
    return $env;
}

/**
 * Backup Create Command - NEW in v1.0.7
 */
class BackupCreateCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('backup:create')
            ->setDescription('ğŸ’¾ Create a database backup')
            ->addArgument('name', InputArgument::OPTIONAL, 'Backup name')
            ->addOption('no-compression', null, InputOption::VALUE_NONE, 'Disable compression')
            ->addOption('structure-only', null, InputOption::VALUE_NONE, 'Backup structure only');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('ğŸ’¾ AdminKit Database Backup');
        
        $pdo = getDatabase();
        if (!$pdo) {
            $io->error('Database connection failed. Please check your .env configuration.');
            return Command::FAILURE;
        }
        
        try {
            require_once __DIR__ . '/../src/Services/BackupService.php';
            
            $config = [
                'compression' => !$input->getOption('no-compression'),
                'include_data' => !$input->getOption('structure-only')
            ];
            
            $backupService = new \AdminKit\Services\BackupService($pdo, $config);
            
            $name = $input->getArgument('name');
            $result = $backupService->createBackup($name);
            
            if ($result['success']) {
                $io->success('Backup created successfully!');
                $io->definitionList(
                    ['Filename' => $result['filename']],
                    ['Size' => number_format($result['size']) . ' bytes'],
                    ['Created' => $result['created_at']],
                    ['Compressed' => $result['compressed'] ? 'Yes' : 'No']
                );
            } else {
                $io->error('Backup failed: ' . $result['error']);
                return Command::FAILURE;
            }
            
        } catch (Exception $e) {
            $io->error('Backup failed: ' . $e->getMessage());
            return Command::FAILURE;
        }
        
        return Command::SUCCESS;
    }
}

/**
 * Backup Restore Command - NEW in v1.0.7
 */
class BackupRestoreCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('backup:restore')
            ->setDescription('â™»ï¸ Restore database from backup')
            ->addArgument('filename', InputArgument::REQUIRED, 'Backup filename');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('â™»ï¸ AdminKit Database Restore');
        
        $pdo = getDatabase();
        if (!$pdo) {
            $io->error('Database connection failed. Please check your .env configuration.');
            return Command::FAILURE;
        }
        
        $filename = $input->getArgument('filename');
        
        if (!$io->confirm("This will restore the database from '{$filename}'. Are you sure?", false)) {
            $io->text('Restore cancelled.');
            return Command::SUCCESS;
        }
        
        try {
            require_once __DIR__ . '/../src/Services/BackupService.php';
            
            $backupService = new \AdminKit\Services\BackupService($pdo);
            $result = $backupService->restoreBackup($filename);
            
            if ($result['success']) {
                $io->success('Database restored successfully!');
                $io->text('Restored at: ' . $result['restored_at']);
            } else {
                $io->error('Restore failed: ' . $result['error']);
                return Command::FAILURE;
            }
            
        } catch (Exception $e) {
            $io->error('Restore failed: ' . $e->getMessage());
            return Command::FAILURE;
        }
        
        return Command::SUCCESS;
    }
}

/**
 * Backup List Command - NEW in v1.0.7
 */
class BackupListCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('backup:list')
            ->setDescription('ğŸ“‹ List available backups');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('ğŸ“‹ Available Backups');
        
        $pdo = getDatabase();
        if (!$pdo) {
            $io->error('Database connection failed. Please check your .env configuration.');
            return Command::FAILURE;
        }
        
        try {
            require_once __DIR__ . '/../src/Services/BackupService.php';
            
            $backupService = new \AdminKit\Services\BackupService($pdo);
            $backups = $backupService->listBackups();
            $stats = $backupService->getBackupStats();
            
            if (empty($backups)) {
                $io->warning('No backups found.');
                return Command::SUCCESS;
            }
            
            $tableData = [];
            foreach ($backups as $backup) {
                $tableData[] = [
                    $backup['filename'],
                    $backup['size_formatted'],
                    $backup['created_at'],
                    $backup['is_compressed'] ? 'Yes' : 'No'
                ];
            }
            
            $io->table(
                ['Filename', 'Size', 'Created', 'Compressed'],
                $tableData
            );
            
            $io->text([
                '',
                "Total backups: {$stats['total_backups']}",
                "Total size: {$stats['total_size_formatted']}",
                "Backup path: {$stats['backup_path']}"
            ]);
            
        } catch (Exception $e) {
            $io->error('Failed to list backups: ' . $e->getMessage());
            return Command::FAILURE;
        }
        
        return Command::SUCCESS;
    }
}

/**
 * Cache Clear Command - NEW in v1.0.7
 */
class CacheClearCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('cache:clear')
            ->setDescription('ğŸ§¹ Clear application cache')
            ->addOption('all', 'a', InputOption::VALUE_NONE, 'Clear all cache types');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('ğŸ§¹ AdminKit Cache Clear');
        
        $cacheDir = getcwd() . '/cache';
        $cleared = 0;
        
        if (is_dir($cacheDir)) {
            $files = glob($cacheDir . '/*');
            foreach ($files as $file) {
                if (is_file($file)) {
                    unlink($file);
                    $cleared++;
                }
            }
        }
        
        // Clear opcache if available
        if (function_exists('opcache_reset')) {
            opcache_reset();
            $io->text('âœ… OPcache cleared');
        }
        
        // Clear realpath cache
        clearstatcache(true);
        $io->text('âœ… Realpath cache cleared');
        
        $io->success("Cache cleared successfully! Removed {$cleared} files.");
        
        return Command::SUCCESS;
    }
}

/**
 * System Status Command - NEW in v1.0.7
 */
class StatusCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('status')
            ->setDescription('ğŸ” Show system status information');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('ğŸ” AdminKit System Status');
        
        // Database status
        $pdo = getDatabase();
        $dbStatus = $pdo ? 'âœ… Connected' : 'âŒ Failed';
        
        // Directory permissions
        $directories = ['cache', 'logs', 'uploads', 'backups'];
        $dirStatus = [];
        
        foreach ($directories as $dir) {
            $path = getcwd() . '/' . $dir;
            if (is_dir($path)) {
                $dirStatus[] = is_writable($path) ? "âœ… {$dir}" : "âŒ {$dir} (not writable)";
            } else {
                $dirStatus[] = "âš ï¸ {$dir} (missing)";
            }
        }
        
        // PHP extensions
        $requiredExtensions = ['pdo', 'json', 'mbstring'];
        $extStatus = [];
        
        foreach ($requiredExtensions as $ext) {
            $extStatus[] = extension_loaded($ext) ? "âœ… {$ext}" : "âŒ {$ext}";
        }
        
        // System info
        $io->section('Database');
        $io->text($dbStatus);
        
        $io->section('Directories');
        $io->listing($dirStatus);
        
        $io->section('PHP Extensions');
        $io->listing($extStatus);
        
        $io->section('System Information');
        $io->definitionList(
            ['PHP Version' => PHP_VERSION],
            ['Memory Limit' => ini_get('memory_limit')],
            ['Max Execution Time' => ini_get('max_execution_time') . 's'],
            ['Upload Max Size' => ini_get('upload_max_filesize')],
            ['Current Working Directory' => getcwd()]
        );
        
        return Command::SUCCESS;
    }
}

/**
 * Config Generate Command - NEW in v1.0.7
 */
class ConfigGenerateCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('config:generate')
            ->setDescription('âš™ï¸ Generate configuration file')
            ->addOption('force', 'f', InputOption::VALUE_NONE, 'Overwrite existing config');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('âš™ï¸ AdminKit Configuration Generator');
        
        $configFile = getcwd() . '/config/adminkit.php';
        $force = $input->getOption('force');
        
        if (file_exists($configFile) && !$force) {
            if (!$io->confirm('Configuration file already exists. Overwrite?', false)) {
                $io->text('Configuration generation cancelled.');
                return Command::SUCCESS;
            }
        }
        
        // Ensure config directory exists
        $configDir = dirname($configFile);
        if (!is_dir($configDir)) {
            mkdir($configDir, 0755, true);
        }
        
        $config = $this->generateConfig();
        file_put_contents($configFile, $config);
        
        $io->success('Configuration file generated successfully!');
        $io->text("Location: {$configFile}");
        
        return Command::SUCCESS;
    }
    
    private function generateConfig(): string
    {
        return <<<'PHP'
<?php

/**
 * AdminKit Configuration v1.0.7
 * Generated automatically by AdminKit CLI
 */

return [
    'app_name' => env('APP_NAME', 'AdminKit Panel'),
    'app_url' => env('APP_URL', 'http://localhost:8000'),
    'timezone' => env('APP_TIMEZONE', 'Europe/Istanbul'),
    'locale' => env('APP_LOCALE', 'tr'),
    'debug' => env('APP_DEBUG', true),
    
    'database' => [
        'driver' => env('DB_CONNECTION', 'mysql'),
        'host' => env('DB_HOST', 'localhost'),
        'port' => env('DB_PORT', 3306),
        'database' => env('DB_DATABASE', 'adminkit'),
        'username' => env('DB_USERNAME', 'root'),
        'password' => env('DB_PASSWORD', ''),
        'charset' => 'utf8mb4',
        'collation' => 'utf8mb4_unicode_ci',
    ],
    
    'auth' => [
        'enabled' => true,
        'session_timeout' => env('AUTH_SESSION_TIMEOUT', 7200),
        '2fa_enabled' => env('AUTH_2FA_ENABLED', true),
        'password_min_length' => env('AUTH_PASSWORD_MIN_LENGTH', 8),
        'max_login_attempts' => env('AUTH_MAX_LOGIN_ATTEMPTS', 5),
        'lockout_duration' => env('AUTH_LOCKOUT_DURATION', 900)
    ],
    
    'cache' => [
        'enabled' => true,
        'driver' => env('CACHE_DRIVER', 'file'),
        'ttl' => env('CACHE_TTL', 3600),
        'prefix' => env('CACHE_PREFIX', 'adminkit_')
    ],
    
    'backup' => [
        'enabled' => true,
        'path' => env('BACKUP_PATH', 'backups'),
        'max_backups' => env('BACKUP_MAX_COUNT', 10),
        'compression' => env('BACKUP_COMPRESSION', true),
        'auto_cleanup' => env('BACKUP_AUTO_CLEANUP', true)
    ],
    
    'performance' => [
        'enabled' => env('PERFORMANCE_ENABLED', true),
        'slow_query_threshold' => env('PERFORMANCE_SLOW_QUERY_THRESHOLD', 1000),
        'memory_limit_warning' => env('PERFORMANCE_MEMORY_LIMIT_WARNING', 80),
        'opcache_enabled' => env('PERFORMANCE_OPCACHE_ENABLED', true)
    ],
    
    'security' => [
        'rate_limiting' => env('SECURITY_RATE_LIMITING', true),
        'csrf_protection' => env('SECURITY_CSRF_PROTECTION', true),
        'secure_headers' => env('SECURITY_SECURE_HEADERS', true),
        'ssl_required' => env('SECURITY_SSL_REQUIRED', false)
    ],
    
    'uploads' => [
        'path' => env('UPLOAD_PATH', 'public/uploads'),
        'max_size' => env('UPLOAD_MAX_SIZE', '10M'),
        'allowed_types' => explode(',', env('UPLOAD_ALLOWED_TYPES', 'jpg,jpeg,png,gif,pdf,docx,xlsx'))
    ],
    
    'api' => [
        'enabled' => env('API_ENABLED', true),
        'rate_limit' => env('API_RATE_LIMIT', 100),
        'auth_required' => env('API_AUTH_REQUIRED', true),
        'version' => env('API_VERSION', 'v1')
    ]
];

// Helper function for environment variables
function env($key, $default = null) {
    static $env = null;
    if ($env === null) {
        $env = [];
        $envFile = __DIR__ . '/../.env';
        if (file_exists($envFile)) {
            $lines = file($envFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
            foreach ($lines as $line) {
                if (strpos($line, '=') !== false && !str_starts_with($line, '#')) {
                    list($k, $v) = explode('=', $line, 2);
                    $env[trim($k)] = trim($v, '"\'');
                }
            }
        }
    }
    
    return $env[$key] ?? $_ENV[$key] ?? $default;
}
PHP;
    }
}

/**
 * Migrate Command - Database Migration Support
 */
class MigrateCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('migrate')
            ->setDescription('ğŸ—„ï¸ Run AdminKit database migrations')
            ->addOption('rollback', 'r', InputOption::VALUE_NONE, 'Rollback the last migration')
            ->addOption('fresh', null, InputOption::VALUE_NONE, 'Drop all tables and re-run migrations')
            ->addOption('force', 'f', InputOption::VALUE_NONE, 'Force migration in production');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('ğŸ—„ï¸ AdminKit Database Migration');
        
        $pdo = getDatabase();
        if (!$pdo) {
            $io->error('Database connection failed. Please check your .env configuration.');
            return Command::FAILURE;
        }
        
        try {
            // Create migrations table if not exists
            $this->createMigrationsTable($pdo);
            
            if ($input->getOption('fresh')) {
                return $this->migrateFresh($pdo, $io);
            } elseif ($input->getOption('rollback')) {
                return $this->rollback($pdo, $io);
            } else {
                return $this->migrate($pdo, $io);
            }
        } catch (Exception $e) {
            $io->error('Migration failed: ' . $e->getMessage());
            return Command::FAILURE;
        }
    }
    
    private function createMigrationsTable(PDO $pdo): void
    {
        $sql = "CREATE TABLE IF NOT EXISTS migrations (
            id INT AUTO_INCREMENT PRIMARY KEY,
            migration VARCHAR(255) NOT NULL,
            executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            INDEX idx_migration (migration)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4";
        
        $pdo->exec($sql);
    }
    
    private function migrate(PDO $pdo, SymfonyStyle $io): int
    {
        $migrationsDir = getcwd() . '/migrations';
        
        if (!is_dir($migrationsDir)) {
            $io->error('Migrations directory not found. Run `php vendor/bin/adminkit install` first.');
            return Command::FAILURE;
        }
        
        // Get executed migrations
        $stmt = $pdo->query("SELECT migration FROM migrations ORDER BY id");
        $executed = $stmt->fetchAll(PDO::FETCH_COLUMN);
        
        // Get migration files
        $files = glob($migrationsDir . '/*.sql');
        sort($files);
        
        $newMigrations = 0;
        
        foreach ($files as $file) {
            $migration = basename($file);
            
            if (!in_array($migration, $executed)) {
                $io->text("Running migration: <comment>{$migration}</comment>");
                
                $sql = file_get_contents($file);
                $pdo->exec($sql);
                
                // Record migration
                $stmt = $pdo->prepare("INSERT INTO migrations (migration) VALUES (?)");
                $stmt->execute([$migration]);
                
                $newMigrations++;
            }
        }
        
        if ($newMigrations > 0) {
            $io->success("Successfully ran {$newMigrations} migrations.");
        } else {
            $io->info('No new migrations to run.');
        }
        
        return Command::SUCCESS;
    }
    
    private function migrateFresh(PDO $pdo, SymfonyStyle $io): int
    {
        if (!$io->confirm('This will drop all tables and re-run migrations. Are you sure?', false)) {
            $io->text('Migration cancelled.');
            return Command::SUCCESS;
        }
        
        // Drop all tables
        $stmt = $pdo->query("SHOW TABLES");
        $tables = $stmt->fetchAll(PDO::FETCH_COLUMN);
        
        $pdo->exec("SET FOREIGN_KEY_CHECKS = 0");
        foreach ($tables as $table) {
            $pdo->exec("DROP TABLE IF EXISTS `{$table}`");
        }
        $pdo->exec("SET FOREIGN_KEY_CHECKS = 1");
        
        $io->text('Dropped all tables.');
        
        // Re-run migrations
        return $this->migrate($pdo, $io);
    }
    
    private function rollback(PDO $pdo, SymfonyStyle $io): int
    {
        $stmt = $pdo->query("SELECT migration FROM migrations ORDER BY id DESC LIMIT 1");
        $lastMigration = $stmt->fetchColumn();
        
        if (!$lastMigration) {
            $io->info('No migrations to rollback.');
            return Command::SUCCESS;
        }
        
        // Simple rollback - just remove from migrations table
        // In a real system, you'd have rollback scripts
        $stmt = $pdo->prepare("DELETE FROM migrations WHERE migration = ?");
        $stmt->execute([$lastMigration]);
        
        $io->success("Rolled back migration: {$lastMigration}");
        $io->warning('Note: This only removes the migration record. Manual cleanup may be required.');
        
        return Command::SUCCESS;
    }
}

/**
 * User Create Command
 */
class UserCreateCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('user:create')
            ->setDescription('ğŸ‘¤ Create an admin user')
            ->addArgument('email', InputArgument::OPTIONAL, 'User email address')
            ->addArgument('password', InputArgument::OPTIONAL, 'User password')
            ->addOption('admin', 'a', InputOption::VALUE_NONE, 'Create user with admin role');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('ğŸ‘¤ Create AdminKit User');
        
        $pdo = getDatabase();
        if (!$pdo) {
            $io->error('Database connection failed. Please check your .env configuration.');
            return Command::FAILURE;
        }
        
        // Check if users table exists
        try {
            $pdo->query("SELECT 1 FROM users LIMIT 1");
        } catch (Exception $e) {
            $io->error('Users table not found. Please run migrations first: php vendor/bin/adminkit migrate');
            return Command::FAILURE;
        }
        
        $email = $input->getArgument('email');
        $password = $input->getArgument('password');
        
        if (!$email) {
            $email = $io->ask('Email address');
        }
        
        if (!$password) {
            $password = $io->askHidden('Password (input hidden)');
        }
        
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            $io->error('Invalid email address.');
            return Command::FAILURE;
        }
        
        if (strlen($password) < 6) {
            $io->error('Password must be at least 6 characters long.');
            return Command::FAILURE;
        }
        
        try {
            // Check if user exists
            $stmt = $pdo->prepare("SELECT id FROM users WHERE email = ?");
            $stmt->execute([$email]);
            
            if ($stmt->fetch()) {
                $io->error('User with this email already exists.');
                return Command::FAILURE;
            }
            
            // Create user
            $hashedPassword = password_hash($password, PASSWORD_DEFAULT);
            $isAdmin = $input->getOption('admin') ? 1 : 0;
            
            $stmt = $pdo->prepare("
                INSERT INTO users (email, password, name, is_active, is_admin, created_at) 
                VALUES (?, ?, ?, 1, ?, NOW())
            ");
            
            $name = explode('@', $email)[0];
            $stmt->execute([$email, $hashedPassword, ucfirst($name), $isAdmin]);
            
            $role = $isAdmin ? 'admin' : 'user';
            $io->success("User created successfully with {$role} privileges!");
            $io->text("Email: <comment>{$email}</comment>");
            
        } catch (Exception $e) {
            $io->error('Failed to create user: ' . $e->getMessage());
            return Command::FAILURE;
        }
        
        return Command::SUCCESS;
    }
}

/**
 * Serve Command - Development Server
 */
class ServeCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('serve')
            ->setDescription('ğŸš€ Start AdminKit development server')
            ->addOption('host', null, InputOption::VALUE_OPTIONAL, 'Server host', 'localhost')
            ->addOption('port', 'p', InputOption::VALUE_OPTIONAL, 'Server port', '8000');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $host = $input->getOption('host');
        $port = $input->getOption('port');
        
        $io->title('ğŸš€ AdminKit Development Server');
        $io->text([
            "Starting server at <comment>http://{$host}:{$port}</comment>",
            'Press Ctrl+C to stop the server',
            ''
        ]);
        
        // Check if public directory exists
        $publicDir = getcwd() . '/public';
        if (!is_dir($publicDir)) {
            $io->error('Public directory not found. Please ensure AdminKit is properly installed.');
            return Command::FAILURE;
        }
        
        // Start PHP development server
        $command = sprintf('php -S %s:%s -t %s', $host, $port, $publicDir);
        passthru($command);
        
        return Command::SUCCESS;
    }
}

/**
 * AdminKit Intelligent Install Command v1.0.7
 */
class InstallCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('install')
            ->setDescription('ğŸš€ Install AdminKit with intelligent setup and comprehensive configuration')
            ->addOption('quiet', 'q', InputOption::VALUE_NONE, 'Suppress output')
            ->addOption('force', 'f', InputOption::VALUE_NONE, 'Force overwrite existing files')
            ->addOption('skip-assets', null, InputOption::VALUE_NONE, 'Skip asset publishing')
            ->addOption('skip-templates', null, InputOption::VALUE_NONE, 'Skip template publishing')
            ->addOption('skip-config', null, InputOption::VALUE_NONE, 'Skip configuration publishing')
            ->addOption('skip-env', null, InputOption::VALUE_NONE, 'Skip environment file creation')
            ->addOption('skip-docker', null, InputOption::VALUE_NONE, 'Skip Docker files publishing')
            ->addOption('with-docker', null, InputOption::VALUE_NONE, 'Include Docker files in installation');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        if (!$input->getOption('quiet')) {
            $io->title('ğŸš€ AdminKit v1.0.7 - Intelligent Installation');
            $io->text([
                'âœ¨ Enhanced CLI tools with backup system',
                'ğŸŒ Multi-language support (TR/EN/DE)',
                'ğŸ”§ Advanced configuration management',
                'âš¡ Performance optimization tools',
                ''
            ]);
        }

        $projectRoot = getcwd();
        $packageRoot = dirname(__DIR__);
        $force = $input->getOption('force');
        $withDocker = $input->getOption('with-docker');

        // Smart Docker detection and interactive setup
        if (!$input->getOption('skip-docker') && !$withDocker && !$input->getOption('quiet')) {
            $io->section('ğŸ³ Docker Setup');
            $io->text([
                'AdminKit can automatically configure Docker for you:',
                'â€¢ Complete development environment with MySQL, Redis, MailHog',
                'â€¢ Production-ready configuration with Nginx optimization',
                'â€¢ One-command deployment: docker-compose up --build -d',
                ''
            ]);
            
            $withDocker = $io->confirm('Do you want to include Docker files for easy setup?', true);
        }

        // Create necessary directories
        $this->createDirectories($projectRoot, $io, $input->getOption('quiet'));

        // Smart environment file creation
        if (!$input->getOption('skip-env')) {
            $this->createEnvironmentFile($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'), $withDocker);
        }

        // Intelligent Docker files publishing
        if ($withDocker && !$input->getOption('skip-docker')) {
            $this->publishDockerFiles($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));
        }

        // Publish assets
        if (!$input->getOption('skip-assets')) {
            $this->publishAssets($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));
        }

        // Publish templates
        if (!$input->getOption('skip-templates')) {
            $this->publishTemplates($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));
        }

        // Publish configuration
        if (!$input->getOption('skip-config')) {
            $this->publishConfig($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));
        }

        // Publish migrations
        $this->publishMigrations($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));

        if (!$input->getOption('quiet')) {
            $io->success('ğŸ‰ AdminKit v1.0.7 installation completed successfully!');
            
            $envExists = file_exists($projectRoot . '/.env');
            $dockerExists = file_exists($projectRoot . '/docker-compose.yml');
            
            $io->section('ğŸ“‹ Next Steps');
            
            if ($dockerExists) {
                $io->text([
                    'ğŸ³ <info>Docker Environment Ready!</info>',
                    '',
                    '1. Start containers:',
                    '   <comment>docker-compose up --build -d</comment>',
                    '',
                    '2. Run database migrations:',
                    '   <comment>docker-compose exec app adminkit migrate</comment>',
                    '',
                    '3. Create admin user:',
                    '   <comment>docker-compose exec app adminkit user:create --admin</comment>',
                    '',
                    '4. ğŸŒ Open AdminKit: <comment>http://localhost:8000</comment>',
                    '',
                    'ğŸ“§ MailHog (Email testing): <comment>http://localhost:8025</comment>',
                    'ğŸ—„ï¸ Adminer (Database): <comment>http://localhost:8080</comment>',
                    ''
                ]);
            } else {
                $io->text([
                    'ğŸ–¥ï¸  <info>Local Development Setup</info>',
                    '',
                    '1. Configure database in .env file',
                    '2. Run migrations: <comment>php vendor/bin/adminkit migrate</comment>',
                    '3. Create admin user: <comment>php vendor/bin/adminkit user:create --admin</comment>',
                    '4. Start server: <comment>php vendor/bin/adminkit serve</comment>',
                    '',
                    'ğŸ³ For Docker setup later: <comment>php vendor/bin/adminkit install --with-docker</comment>',
                    ''
                ]);
            }
            
            $io->text([
                '<info>ğŸš€ AdminKit v1.0.7 New Features:</info>',
                'â€¢ âœ… Advanced backup system (create, restore, list)',
                'â€¢ âœ… Enhanced CLI tools (cache, status, config)',
                'â€¢ âœ… Multi-language support (German added)',
                'â€¢ âœ… Performance optimization tools',
                'â€¢ âœ… Comprehensive system monitoring'
            ]);
        }

        return Command::SUCCESS;
    }

    private function createDirectories(string $projectRoot, SymfonyStyle $io, bool $quiet): void
    {
        $directories = [
            'public/assets/adminkit',
            'config',
            'templates/adminkit',
            'migrations',
            'cache',
            'logs',
            'uploads',
            'backups'  // New in v1.0.7
        ];

        foreach ($directories as $dir) {
            $path = $projectRoot . '/' . $dir;
            if (!is_dir($path)) {
                mkdir($path, 0755, true);
                if (!$quiet) {
                    $io->text("ğŸ“ Created directory: <comment>{$dir}</comment>");
                }
            }
        }
    }

    private function createEnvironmentFile(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet, bool $withDocker = false): void
    {
        $envFile = $projectRoot . '/.env';
        $envExampleFile = $projectRoot . '/.env.example';
        
        // First, copy .env.example if it doesn't exist
        $packageEnvExample = $packageRoot . '/.env.example';
        if (file_exists($packageEnvExample) && (!file_exists($envExampleFile) || $force)) {
            copy($packageEnvExample, $envExampleFile);
            if (!$quiet) {
                $io->text('ğŸ“„ Published .env.example file');
            }
        }
        
        // Create .env file if it doesn't exist
        if (!file_exists($envFile) || $force) {
            if (file_exists($envExampleFile)) {
                $envContent = file_get_contents($envExampleFile);
            } elseif (file_exists($packageEnvExample)) {
                $envContent = file_get_contents($packageEnvExample);
            } else {
                $envContent = $this->getBasicEnvContent();
            }
            
            // Smart environment configuration for Docker
            if ($withDocker) {
                $envContent = $this->updateEnvForDocker($envContent);
            }
            
            file_put_contents($envFile, $envContent);
            
            if (!$quiet) {
                $dockerMsg = $withDocker ? ' (ğŸ³ configured for Docker)' : ' (ğŸ–¥ï¸  configured for local)';
                $io->text("âœ… Created .env file{$dockerMsg}");
            }
        } else {
            if (!$quiet) {
                $io->text('â„¹ï¸  .env file already exists (use --force to overwrite)');
            }
        }
    }

    private function updateEnvForDocker(string $envContent): string
    {
        // Smart Docker service configuration
        $dockerUpdates = [
            'DB_HOST' => 'mysql',
            'DB_DATABASE' => 'adminkit',
            'DB_USERNAME' => 'adminkit',
            'DB_PASSWORD' => 'adminkit123',
            'CACHE_DRIVER' => 'redis',
            'REDIS_HOST' => 'redis',
            'QUEUE_CONNECTION' => 'redis',
            'MAIL_HOST' => 'mailhog',
            'MAIL_PORT' => '1025'
        ];
        
        foreach ($dockerUpdates as $key => $value) {
            $envContent = preg_replace("/^{$key}=.*/m", "{$key}={$value}", $envContent);
        }
        
        return $envContent;
    }

    private function publishDockerFiles(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $dockerExampleDir = $packageRoot . '/docker/example';
        
        if (!is_dir($dockerExampleDir)) {
            if (!$quiet) {
                $io->warning('âš ï¸  Docker example files not found in package');
            }
            return;
        }
        
        $filesToCopy = [
            'Dockerfile' => 'Dockerfile',
            'docker-compose.yml' => 'docker-compose.yml',
            'docker/nginx.conf' => 'docker/nginx.conf',
            'docker/php.ini' => 'docker/php.ini',
            'docker/supervisord.conf' => 'docker/supervisord.conf'
        ];
        
        foreach ($filesToCopy as $source => $target) {
            $sourceFile = $dockerExampleDir . '/' . $source;
            $targetFile = $projectRoot . '/' . $target;
            
            if (file_exists($sourceFile)) {
                // Create target directory if needed
                $targetDir = dirname($targetFile);
                if (!is_dir($targetDir)) {
                    mkdir($targetDir, 0755, true);
                }
                
                if (!file_exists($targetFile) || $force) {
                    copy($sourceFile, $targetFile);
                    if (!$quiet) {
                        $io->text("ğŸ³ Published Docker file: <comment>{$target}</comment>");
                    }
                }
            }
        }
        
        if (!$quiet) {
            $io->text('âœ… Docker files published successfully');
        }
    }

    private function getBasicEnvContent(): string
    {
        return <<<ENV
# AdminKit v1.0.7 Environment Configuration

# Application Settings
APP_NAME="AdminKit Panel"
APP_URL=http://localhost:8000
APP_DEBUG=true
APP_TIMEZONE=Europe/Istanbul
APP_LOCALE=tr

# Database Configuration
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=adminkit
DB_USERNAME=root
DB_PASSWORD=

# Cache Configuration
CACHE_DRIVER=file
CACHE_TTL=3600
REDIS_HOST=127.0.0.1
REDIS_PORT=6379

# Queue Configuration
QUEUE_CONNECTION=database

# Backup Configuration (New in v1.0.7)
BACKUP_PATH=backups
BACKUP_MAX_COUNT=10
BACKUP_COMPRESSION=true
BACKUP_AUTO_CLEANUP=true

# Performance Configuration
PERFORMANCE_ENABLED=true
PERFORMANCE_OPCACHE_ENABLED=true
PERFORMANCE_SLOW_QUERY_THRESHOLD=1000

# Security Configuration
SECURITY_RATE_LIMITING=true
SECURITY_CSRF_PROTECTION=true
SECURITY_SECURE_HEADERS=true

# Mail Configuration
MAIL_MAILER=smtp
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=
MAIL_PASSWORD=
MAIL_ENCRYPTION=tls

# Authentication Settings
AUTH_2FA_ENABLED=true
AUTH_SESSION_TIMEOUT=7200
AUTH_PASSWORD_MIN_LENGTH=8
ENV;
    }

    private function publishAssets(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $sourceDir = $packageRoot . '/assets';
        $targetDir = $projectRoot . '/public/assets/adminkit';

        if (is_dir($sourceDir)) {
            $this->copyDirectory($sourceDir, $targetDir, $force);
            if (!$quiet) {
                $io->text('ğŸ¨ Published assets to public/assets/adminkit');
            }
        }
    }

    private function publishTemplates(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $sourceDir = $packageRoot . '/templates';
        $targetDir = $projectRoot . '/templates/adminkit';

        if (is_dir($sourceDir)) {
            $this->copyDirectory($sourceDir, $targetDir, $force);
            if (!$quiet) {
                $io->text('ğŸ“„ Published templates to templates/adminkit');
            }
        }
    }

    private function publishConfig(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $configFile = $projectRoot . '/config/adminkit.php';
        
        if (!file_exists($configFile) || $force) {
            $defaultConfig = $this->getDefaultConfig();
            file_put_contents($configFile, $defaultConfig);
            if (!$quiet) {
                $io->text('âš™ï¸  Published configuration to config/adminkit.php');
            }
        }
    }

    private function publishMigrations(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $sourceDir = $packageRoot . '/migrations';
        $targetDir = $projectRoot . '/migrations';

        if (is_dir($sourceDir)) {
            $files = glob($sourceDir . '/*.sql');
            foreach ($files as $file) {
                $targetFile = $targetDir . '/' . basename($file);
                if (!file_exists($targetFile) || $force) {
                    copy($file, $targetFile);
                }
            }
            if (!$quiet) {
                $io->text('ğŸ—„ï¸  Published migrations to migrations/');
            }
        }
    }

    private function copyDirectory(string $source, string $target, bool $force): void
    {
        if (!is_dir($target)) {
            mkdir($target, 0755, true);
        }

        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($source, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );

        foreach ($iterator as $item) {
            $targetPath = $target . DIRECTORY_SEPARATOR . $iterator->getSubPathName();
            
            if ($item->isDir()) {
                if (!is_dir($targetPath)) {
                    mkdir($targetPath, 0755, true);
                }
            } else {
                if (!file_exists($targetPath) || $force) {
                    copy($item->getPathname(), $targetPath);
                }
            }
        }
    }

    private function getDefaultConfig(): string
    {
        return <<<'PHP'
<?php

return [
    'app_name' => env('APP_NAME', 'AdminKit Panel'),
    'app_url' => env('APP_URL', 'http://localhost:8000'),
    'timezone' => env('APP_TIMEZONE', 'Europe/Istanbul'),
    'locale' => env('APP_LOCALE', 'tr'),
    'debug' => env('APP_DEBUG', true),
    
    'database' => [
        'driver' => env('DB_CONNECTION', 'mysql'),
        'host' => env('DB_HOST', 'localhost'),
        'port' => env('DB_PORT', 3306),
        'database' => env('DB_DATABASE', 'adminkit'),
        'username' => env('DB_USERNAME', 'root'),
        'password' => env('DB_PASSWORD', ''),
        'charset' => 'utf8mb4',
        'collation' => 'utf8mb4_unicode_ci',
    ],
    
    'auth' => [
        'enabled' => true,
        'session_timeout' => env('AUTH_SESSION_TIMEOUT', 7200),
        '2fa_enabled' => env('AUTH_2FA_ENABLED', true),
        'password_min_length' => env('AUTH_PASSWORD_MIN_LENGTH', 8),
        'max_login_attempts' => env('AUTH_MAX_LOGIN_ATTEMPTS', 5),
        'lockout_duration' => env('AUTH_LOCKOUT_DURATION', 900)
    ],
    
    'cache' => [
        'enabled' => true,
        'driver' => env('CACHE_DRIVER', 'file'),
        'ttl' => env('CACHE_TTL', 3600),
        'prefix' => env('CACHE_PREFIX', 'adminkit_')
    ],
    
    'backup' => [
        'enabled' => true,
        'path' => env('BACKUP_PATH', 'backups'),
        'max_backups' => env('BACKUP_MAX_COUNT', 10),
        'compression' => env('BACKUP_COMPRESSION', true)
    ],
    
    'uploads' => [
        'path' => env('UPLOAD_PATH', 'public/uploads'),
        'max_size' => env('UPLOAD_MAX_SIZE', '10M'),
        'allowed_types' => explode(',', env('UPLOAD_ALLOWED_TYPES', 'jpg,jpeg,png,gif,pdf,docx,xlsx'))
    ]
];

// Helper function for environment variables
function env($key, $default = null) {
    static $env = null;
    if ($env === null) {
        $env = [];
        $envFile = __DIR__ . '/../.env';
        if (file_exists($envFile)) {
            $lines = file($envFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
            foreach ($lines as $line) {
                if (strpos($line, '=') !== false && !str_starts_with($line, '#')) {
                    list($k, $v) = explode('=', $line, 2);
                    $env[trim($k)] = trim($v, '"\'');
                }
            }
        }
    }
    
    return $env[$key] ?? $_ENV[$key] ?? $default;
}
PHP;
    }
}

/**
 * Update Command
 */
class UpdateCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('update')
            ->setDescription('ğŸ”„ Update AdminKit package files')
            ->addOption('quiet', 'q', InputOption::VALUE_NONE, 'Suppress output');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        if (!$input->getOption('quiet')) {
            $io->title('ğŸ”„ AdminKit v1.0.7 Update');
            $io->text('Updating AdminKit package files...');
        }

        $installCommand = new InstallCommand();
        $installInput = clone $input;
        $installInput->setOption('force', true);
        
        return $installCommand->execute($installInput, $output);
    }
}

/**
 * Version Command
 */
class VersionCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('version')
            ->setDescription('ğŸ“‹ Show AdminKit version information');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $io->title('ğŸ“‹ AdminKit Version Information');
        $io->definitionList(
            ['AdminKit version' => '1.0.7'],
            ['Release date' => '2025-01-07'],
            ['PHP version' => PHP_VERSION],
            ['Features' => 'Advanced backup system, Multi-language support, Enhanced CLI tools'],
        );
        
        $io->text([
            '',
            '<info>ğŸš€ AdminKit v1.0.7 Features:</info>',
            'â€¢ âœ… Comprehensive backup & restore system',
            'â€¢ âœ… Enhanced CLI tools (cache, status, config)',
            'â€¢ âœ… Multi-language support (TR/EN/DE)',
            'â€¢ âœ… Performance optimization tools',
            'â€¢ âœ… Advanced configuration management',
            'â€¢ âœ… System monitoring & diagnostics',
            '',
            '<info>ğŸ”§ Available Commands:</info>',
            'â€¢ backup:create - Create database backup',
            'â€¢ backup:restore - Restore from backup',
            'â€¢ backup:list - List available backups',
            'â€¢ cache:clear - Clear application cache',
            'â€¢ config:generate - Generate configuration',
            'â€¢ status - Show system status',
            'â€¢ migrate - Database migrations',
            'â€¢ user:create - Create admin users',
            'â€¢ serve - Development server'
        ]);
        
        return Command::SUCCESS;
    }
}

// Create and run application
$application = new Application('AdminKit', '1.0.7');

// Installation & Management
$application->add(new InstallCommand());
$application->add(new UpdateCommand());
$application->add(new VersionCommand());

// Database & Migration
$application->add(new MigrateCommand());

// User Management
$application->add(new UserCreateCommand());

// Backup System (New in v1.0.7)
$application->add(new BackupCreateCommand());
$application->add(new BackupRestoreCommand());
$application->add(new BackupListCommand());

// System Tools (New in v1.0.7)
$application->add(new CacheClearCommand());
$application->add(new StatusCommand());
$application->add(new ConfigGenerateCommand());

// Development
$application->add(new ServeCommand());

$application->run();

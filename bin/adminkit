#!/usr/bin/env php
<?php

declare(strict_types=1);

/*
 * AdminKit Console Application
 * 
 * Enterprise admin panel CLI tool for installation, asset management,
 * and maintenance operations.
 */

// Find autoloader
$autoloaderPaths = [
    __DIR__ . '/../vendor/autoload.php',      // Package development
    __DIR__ . '/../../../autoload.php',      // Package installed in project
    __DIR__ . '/../../../../autoload.php',   // Package installed globally
];

$autoloaderFound = false;
foreach ($autoloaderPaths as $path) {
    if (file_exists($path)) {
        require_once $path;
        $autoloaderFound = true;
        break;
    }
}

if (!$autoloaderFound) {
    fwrite(STDERR, "Error: Could not find Composer autoloader.\n");
    fwrite(STDERR, "Please run 'composer install' first.\n");
    exit(1);
}

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Console\Question\Question;
use Symfony\Component\Console\Question\ChoiceQuestion;

/**
 * Helper function to get database connection
 */
function getDatabase(): ?PDO
{
    $configFile = getcwd() . '/config/adminkit.php';
    if (!file_exists($configFile)) {
        return null;
    }
    
    $config = require $configFile;
    $db = $config['database'] ?? [];
    
    try {
        $dsn = sprintf('%s:host=%s;port=%s;dbname=%s;charset=%s',
            $db['driver'] ?? 'mysql',
            $db['host'] ?? 'localhost',
            $db['port'] ?? 3306,
            $db['database'] ?? '',
            $db['charset'] ?? 'utf8mb4'
        );
        
        return new PDO($dsn, $db['username'] ?? '', $db['password'] ?? '', [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
        ]);
    } catch (Exception $e) {
        return null;
    }
}

/**
 * Enhanced Environment loader
 */
function loadEnvironment(): array
{
    $envFile = getcwd() . '/.env';
    $env = [];
    
    if (file_exists($envFile)) {
        $lines = file($envFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
        foreach ($lines as $line) {
            if (strpos($line, '=') !== false && !str_starts_with($line, '#')) {
                list($key, $value) = explode('=', $line, 2);
                $env[trim($key)] = trim($value, '"\'');
            }
        }
    }
    
    return $env;
}

/**
 * AdminKit Install Command
 */
class InstallCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('install')
            ->setDescription('Install AdminKit assets, templates, and configuration')
            ->addOption('quiet', 'q', InputOption::VALUE_NONE, 'Suppress output')
            ->addOption('force', 'f', InputOption::VALUE_NONE, 'Force overwrite existing files')
            ->addOption('skip-assets', null, InputOption::VALUE_NONE, 'Skip asset publishing')
            ->addOption('skip-templates', null, InputOption::VALUE_NONE, 'Skip template publishing')
            ->addOption('skip-config', null, InputOption::VALUE_NONE, 'Skip configuration publishing');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        if (!$input->getOption('quiet')) {
            $io->title('AdminKit Installation');
            $io->text('Installing AdminKit package files...');
        }

        $projectRoot = getcwd();
        $packageRoot = dirname(__DIR__);
        $force = $input->getOption('force');

        // Create necessary directories
        $this->createDirectories($projectRoot, $io, $input->getOption('quiet'));

        // Publish assets
        if (!$input->getOption('skip-assets')) {
            $this->publishAssets($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));
        }

        // Publish templates
        if (!$input->getOption('skip-templates')) {
            $this->publishTemplates($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));
        }

        // Publish configuration
        if (!$input->getOption('skip-config')) {
            $this->publishConfig($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));
        }

        // Publish migrations
        $this->publishMigrations($packageRoot, $projectRoot, $force, $io, $input->getOption('quiet'));

        if (!$input->getOption('quiet')) {
            $io->success('AdminKit installation completed successfully!');
            $io->text([
                'Next steps:',
                '1. Copy environment file: php vendor/bin/adminkit env:copy',
                '2. Configure your database in .env file',
                '3. Run migrations: php vendor/bin/adminkit migrate',
                '4. Create admin user: php vendor/bin/adminkit user:create',
                '5. Start development server: php vendor/bin/adminkit serve'
            ]);
        }

        return Command::SUCCESS;
    }

    private function createDirectories(string $projectRoot, SymfonyStyle $io, bool $quiet): void
    {
        $directories = [
            'public/assets/adminkit',
            'config',
            'templates/adminkit',
            'migrations',
            'cache',
            'logs',
            'uploads'
        ];

        foreach ($directories as $dir) {
            $path = $projectRoot . '/' . $dir;
            if (!is_dir($path)) {
                mkdir($path, 0755, true);
                if (!$quiet) {
                    $io->text("Created directory: {$dir}");
                }
            }
        }
    }

    private function publishAssets(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $sourceDir = $packageRoot . '/assets';
        $targetDir = $projectRoot . '/public/assets/adminkit';

        if (is_dir($sourceDir)) {
            $this->copyDirectory($sourceDir, $targetDir, $force);
            if (!$quiet) {
                $io->text('Published assets to public/assets/adminkit');
            }
        }
    }

    private function publishTemplates(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $sourceDir = $packageRoot . '/templates';
        $targetDir = $projectRoot . '/templates/adminkit';

        if (is_dir($sourceDir)) {
            $this->copyDirectory($sourceDir, $targetDir, $force);
            if (!$quiet) {
                $io->text('Published templates to templates/adminkit');
            }
        }
    }

    private function publishConfig(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $configFile = $projectRoot . '/config/adminkit.php';
        
        if (!file_exists($configFile) || $force) {
            $defaultConfig = $this->getDefaultConfig();
            file_put_contents($configFile, $defaultConfig);
            if (!$quiet) {
                $io->text('Published configuration to config/adminkit.php');
            }
        }
    }

    private function publishMigrations(string $packageRoot, string $projectRoot, bool $force, SymfonyStyle $io, bool $quiet): void
    {
        $sourceDir = $packageRoot . '/migrations';
        $targetDir = $projectRoot . '/migrations';

        if (is_dir($sourceDir)) {
            $files = glob($sourceDir . '/*.sql');
            foreach ($files as $file) {
                $targetFile = $targetDir . '/' . basename($file);
                if (!file_exists($targetFile) || $force) {
                    copy($file, $targetFile);
                }
            }
            if (!$quiet) {
                $io->text('Published migrations to migrations/');
            }
        }
    }

    private function copyDirectory(string $source, string $target, bool $force): void
    {
        if (!is_dir($target)) {
            mkdir($target, 0755, true);
        }

        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($source, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );

        foreach ($iterator as $item) {
            $targetPath = $target . DIRECTORY_SEPARATOR . $iterator->getSubPathName();
            
            if ($item->isDir()) {
                if (!is_dir($targetPath)) {
                    mkdir($targetPath, 0755, true);
                }
            } else {
                if (!file_exists($targetPath) || $force) {
                    copy($item->getPathname(), $targetPath);
                }
            }
        }
    }

    private function getDefaultConfig(): string
    {
        return <<<'PHP'
<?php

return [
    'app_name' => env('APP_NAME', 'AdminKit Panel'),
    'app_url' => env('APP_URL', 'http://localhost:8000'),
    'timezone' => env('APP_TIMEZONE', 'Europe/Istanbul'),
    'locale' => env('APP_LOCALE', 'tr'),
    'debug' => env('APP_DEBUG', true),
    
    'database' => [
        'driver' => env('DB_CONNECTION', 'mysql'),
        'host' => env('DB_HOST', 'localhost'),
        'port' => env('DB_PORT', 3306),
        'database' => env('DB_DATABASE', 'adminkit'),
        'username' => env('DB_USERNAME', 'root'),
        'password' => env('DB_PASSWORD', ''),
        'charset' => 'utf8mb4',
        'collation' => 'utf8mb4_unicode_ci',
    ],
    
    'auth' => [
        'enabled' => true,
        'session_timeout' => env('AUTH_SESSION_TIMEOUT', 7200),
        '2fa_enabled' => env('AUTH_2FA_ENABLED', true),
        'password_min_length' => env('AUTH_PASSWORD_MIN_LENGTH', 8),
        'max_login_attempts' => env('AUTH_MAX_LOGIN_ATTEMPTS', 5),
        'lockout_duration' => env('AUTH_LOCKOUT_DURATION', 900)
    ],
    
    'cache' => [
        'enabled' => true,
        'driver' => env('CACHE_DRIVER', 'file'),
        'ttl' => env('CACHE_TTL', 3600),
        'prefix' => env('CACHE_PREFIX', 'adminkit_')
    ],
    
    'queue' => [
        'enabled' => true,
        'driver' => env('QUEUE_CONNECTION', 'database'),
        'table' => env('QUEUE_TABLE', 'jobs'),
        'max_attempts' => env('QUEUE_MAX_ATTEMPTS', 3),
        'retry_delay' => env('QUEUE_RETRY_DELAY', 60)
    ],
    
    'websocket' => [
        'enabled' => env('WEBSOCKET_ENABLED', false),
        'port' => env('WEBSOCKET_PORT', 8080),
        'host' => env('WEBSOCKET_HOST', '0.0.0.0')
    ],
    
    'performance' => [
        'enabled' => env('PERFORMANCE_ENABLED', true),
        'slow_query_threshold' => env('PERFORMANCE_SLOW_QUERY_THRESHOLD', 1000),
        'memory_limit_warning' => env('PERFORMANCE_MEMORY_LIMIT_WARNING', 80)
    ],
    
    'uploads' => [
        'path' => env('UPLOAD_PATH', 'public/uploads'),
        'max_size' => env('UPLOAD_MAX_SIZE', '10M'),
        'allowed_types' => explode(',', env('UPLOAD_ALLOWED_TYPES', 'jpg,jpeg,png,gif,pdf,docx,xlsx'))
    ]
];

// Helper function for environment variables
function env($key, $default = null) {
    static $env = null;
    if ($env === null) {
        $env = [];
        $envFile = __DIR__ . '/../.env';
        if (file_exists($envFile)) {
            $lines = file($envFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
            foreach ($lines as $line) {
                if (strpos($line, '=') !== false && !str_starts_with($line, '#')) {
                    list($k, $v) = explode('=', $line, 2);
                    $env[trim($k)] = trim($v, '"\'');
                }
            }
        }
    }
    
    return $env[$key] ?? $_ENV[$key] ?? $default;
}
PHP;
    }
}

/**
 * Environment Copy Command
 */
class EnvCopyCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('env:copy')
            ->setDescription('Copy .env.example to .env')
            ->addOption('force', 'f', InputOption::VALUE_NONE, 'Force overwrite existing .env file');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $projectRoot = getcwd();
        $envExample = $projectRoot . '/.env.example';
        $envFile = $projectRoot . '/.env';
        
        if (!file_exists($envExample)) {
            // Try to copy from package
            $packageRoot = dirname(__DIR__);
            $packageEnvExample = $packageRoot . '/.env.example';
            
            if (file_exists($packageEnvExample)) {
                copy($packageEnvExample, $envExample);
                $io->text('Copied .env.example from AdminKit package');
            } else {
                $io->error('.env.example file not found');
                return Command::FAILURE;
            }
        }
        
        if (file_exists($envFile) && !$input->getOption('force')) {
            $io->warning('.env file already exists. Use --force to overwrite.');
            return Command::FAILURE;
        }
        
        copy($envExample, $envFile);
        $io->success('.env file created successfully!');
        $io->text('Please configure your environment variables in .env file');
        
        return Command::SUCCESS;
    }
}

/**
 * Environment Check Command
 */
class EnvCheckCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('env:check')
            ->setDescription('Check environment configuration');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        $io->title('Environment Configuration Check');
        
        $env = loadEnvironment();
        $issues = [];
        
        // Check required variables
        $required = ['APP_NAME', 'APP_URL', 'DB_HOST', 'DB_DATABASE', 'DB_USERNAME'];
        foreach ($required as $key) {
            if (!isset($env[$key]) || empty($env[$key])) {
                $issues[] = "Missing required variable: {$key}";
            }
        }
        
        // Check database connection
        if (isset($env['DB_HOST'])) {
            try {
                $pdo = getDatabase();
                if ($pdo) {
                    $io->text('âœ… Database connection: OK');
                } else {
                    $issues[] = 'Database connection failed';
                }
            } catch (Exception $e) {
                $issues[] = 'Database connection error: ' . $e->getMessage();
            }
        }
        
        if (empty($issues)) {
            $io->success('Environment configuration is valid!');
            return Command::SUCCESS;
        } else {
            $io->error('Environment configuration issues found:');
            foreach ($issues as $issue) {
                $io->text('âŒ ' . $issue);
            }
            return Command::FAILURE;
        }
    }
}

/**
 * Docker Up Command
 */
class DockerUpCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('docker:up')
            ->setDescription('Start Docker containers')
            ->addOption('build', 'b', InputOption::VALUE_NONE, 'Build images before starting')
            ->addOption('detach', 'd', InputOption::VALUE_NONE, 'Run in detached mode');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        if (!file_exists('docker-compose.yml')) {
            $io->error('docker-compose.yml not found. Please run this command from AdminKit root directory.');
            return Command::FAILURE;
        }
        
        $command = 'docker-compose up';
        
        if ($input->getOption('build')) {
            $command .= ' --build';
        }
        
        if ($input->getOption('detach')) {
            $command .= ' -d';
        }
        
        $io->text("Starting Docker containers...");
        $io->text("Command: {$command}");
        
        passthru($command, $exitCode);
        
        if ($exitCode === 0) {
            $io->success('Docker containers started successfully!');
            $io->text([
                'Services available:',
                'ðŸŒ AdminKit: http://localhost:8000',
                'ðŸ“§ MailHog: http://localhost:8025',
                'ðŸ—„ï¸ Adminer: http://localhost:8080',
            ]);
        } else {
            $io->error('Failed to start Docker containers');
        }
        
        return $exitCode;
    }
}

/**
 * Docker Down Command
 */
class DockerDownCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('docker:down')
            ->setDescription('Stop Docker containers')
            ->addOption('volumes', 'v', InputOption::VALUE_NONE, 'Remove volumes');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        $command = 'docker-compose down';
        
        if ($input->getOption('volumes')) {
            $command .= ' -v';
        }
        
        $io->text("Stopping Docker containers...");
        passthru($command, $exitCode);
        
        if ($exitCode === 0) {
            $io->success('Docker containers stopped successfully!');
        } else {
            $io->error('Failed to stop Docker containers');
        }
        
        return $exitCode;
    }
}

/**
 * User Create Command
 */
class UserCreateCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('user:create')
            ->setDescription('Create admin user')
            ->addArgument('name', InputArgument::OPTIONAL, 'User name')
            ->addArgument('email', InputArgument::OPTIONAL, 'User email')
            ->addArgument('password', InputArgument::OPTIONAL, 'User password');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        $io->title('Create Admin User');

        $pdo = getDatabase();
        if (!$pdo) {
            $io->error('Could not connect to database. Please check your configuration.');
            return Command::FAILURE;
        }

        // Get user input
        $name = $input->getArgument('name') ?: $io->ask('Name', 'Admin User');
        $email = $input->getArgument('email') ?: $io->ask('Email', 'admin@example.com');
        $password = $input->getArgument('password') ?: $io->askHidden('Password (leave empty for random)');
        
        if (!$password) {
            $password = bin2hex(random_bytes(8));
            $io->note("Generated password: {$password}");
        }

        try {
            // Check if users table exists
            $stmt = $pdo->query("SHOW TABLES LIKE 'users'");
            if (!$stmt->fetch()) {
                $io->error('Users table not found. Please run migrations first: php vendor/bin/adminkit migrate');
                return Command::FAILURE;
            }

            // Check if user already exists
            $stmt = $pdo->prepare("SELECT id FROM users WHERE email = ?");
            $stmt->execute([$email]);
            if ($stmt->fetch()) {
                $io->error("User with email {$email} already exists.");
                return Command::FAILURE;
            }

            // Create user
            $hashedPassword = password_hash($password, PASSWORD_DEFAULT);
            $stmt = $pdo->prepare("
                INSERT INTO users (name, email, password, is_active, created_at) 
                VALUES (?, ?, ?, 1, NOW())
            ");
            $stmt->execute([$name, $email, $hashedPassword]);

            $io->success("Admin user created successfully!");
            $io->table(['Field', 'Value'], [
                ['Name', $name],
                ['Email', $email],
                ['Password', $password]
            ]);

        } catch (Exception $e) {
            $io->error("Failed to create user: " . $e->getMessage());
            return Command::FAILURE;
        }

        return Command::SUCCESS;
    }
}

/**
 * Migrate Command
 */
class MigrateCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('migrate')
            ->setDescription('Run database migrations')
            ->addOption('rollback', null, InputOption::VALUE_NONE, 'Rollback last migration');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        $io->title('Database Migrations');

        $pdo = getDatabase();
        if (!$pdo) {
            $io->error('Could not connect to database. Please check your configuration.');
            return Command::FAILURE;
        }

        try {
            if ($input->getOption('rollback')) {
                return $this->rollback($io, $pdo);
            } else {
                return $this->migrate($io, $pdo);
            }
        } catch (Exception $e) {
            $io->error("Migration failed: " . $e->getMessage());
            return Command::FAILURE;
        }
    }

    private function migrate(SymfonyStyle $io, PDO $pdo): int
    {
        // Create migrations table if not exists
        $pdo->exec("
            CREATE TABLE IF NOT EXISTS migrations (
                id INT AUTO_INCREMENT PRIMARY KEY,
                migration VARCHAR(255) NOT NULL,
                executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ");

        $migrationsDir = getcwd() . '/migrations';
        if (!is_dir($migrationsDir)) {
            $io->error('Migrations directory not found.');
            return Command::FAILURE;
        }

        $files = glob($migrationsDir . '/*.sql');
        if (empty($files)) {
            $io->warning('No migration files found.');
            return Command::SUCCESS;
        }

        $executed = [];
        $stmt = $pdo->query("SELECT migration FROM migrations");
        while ($row = $stmt->fetch()) {
            $executed[] = $row['migration'];
        }

        $migrations = 0;
        foreach ($files as $file) {
            $migration = basename($file);
            if (in_array($migration, $executed)) {
                continue;
            }

            $sql = file_get_contents($file);
            $pdo->exec($sql);

            $stmt = $pdo->prepare("INSERT INTO migrations (migration) VALUES (?)");
            $stmt->execute([$migration]);

            $io->text("Executed: {$migration}");
            $migrations++;
        }

        if ($migrations > 0) {
            $io->success("Executed {$migrations} migrations successfully!");
        } else {
            $io->info('No new migrations to execute.');
        }

        return Command::SUCCESS;
    }

    private function rollback(SymfonyStyle $io, PDO $pdo): int
    {
        $io->warning('Migration rollback is not implemented yet.');
        return Command::SUCCESS;
    }
}

/**
 * Serve Command
 */
class ServeCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('serve')
            ->setDescription('Start development server')
            ->addOption('port', 'p', InputOption::VALUE_OPTIONAL, 'Port number', '8000')
            ->addOption('host', null, InputOption::VALUE_OPTIONAL, 'Host address', 'localhost');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        $port = $input->getOption('port');
        $host = $input->getOption('host');

        $publicDir = getcwd() . '/public';
        if (!is_dir($publicDir)) {
            $io->error('Public directory not found. Please run: php vendor/bin/adminkit install');
            return Command::FAILURE;
        }

        $io->success("AdminKit development server started!");
        $io->text("Server running at: http://{$host}:{$port}");
        $io->text("Press Ctrl+C to stop the server");

        $command = "php -S {$host}:{$port} -t {$publicDir}";
        passthru($command);

        return Command::SUCCESS;
    }
}

/**
 * Queue Work Command
 */
class QueueWorkCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('queue:work')
            ->setDescription('Start queue worker')
            ->addOption('queue', null, InputOption::VALUE_OPTIONAL, 'Queue name', 'default')
            ->addOption('timeout', null, InputOption::VALUE_OPTIONAL, 'Worker timeout', '60');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        $queue = $input->getOption('queue');
        $timeout = (int) $input->getOption('timeout');

        $io->success("Queue worker started for queue: {$queue}");
        $io->text("Worker timeout: {$timeout} seconds");
        $io->text("Press Ctrl+C to stop the worker");

        // Basic queue worker simulation
        $startTime = time();
        while (time() - $startTime < $timeout) {
            $io->text(date('Y-m-d H:i:s') . " - Checking for jobs...");
            sleep(5);
        }

        $io->info("Queue worker stopped.");
        return Command::SUCCESS;
    }
}

/**
 * Cache Clear Command
 */
class CacheClearCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('cache:clear')
            ->setDescription('Clear cache files');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);

        $cacheDir = getcwd() . '/cache';
        if (is_dir($cacheDir)) {
            $this->clearDirectory($cacheDir);
            $io->success('Cache cleared successfully!');
        } else {
            $io->info('No cache directory found.');
        }

        return Command::SUCCESS;
    }

    private function clearDirectory(string $dir): void
    {
        $files = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($dir, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::CHILD_FIRST
        );

        foreach ($files as $file) {
            if ($file->isDir()) {
                rmdir($file->getRealPath());
            } else {
                unlink($file->getRealPath());
            }
        }
    }
}

/**
 * Update Command
 */
class UpdateCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('update')
            ->setDescription('Update AdminKit package files')
            ->addOption('quiet', 'q', InputOption::VALUE_NONE, 'Suppress output');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        
        if (!$input->getOption('quiet')) {
            $io->title('AdminKit Update');
            $io->text('Updating AdminKit package files...');
        }

        $installCommand = new InstallCommand();
        $installInput = clone $input;
        $installInput->setOption('force', true);
        
        return $installCommand->execute($installInput, $output);
    }
}

/**
 * Publish Assets Command
 */
class PublishAssetsCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('publish:assets')
            ->setDescription('Publish AdminKit assets');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        $packageRoot = dirname(__DIR__);
        $projectRoot = getcwd();

        $sourceDir = $packageRoot . '/assets';
        $targetDir = $projectRoot . '/public/assets/adminkit';

        if (is_dir($sourceDir)) {
            $this->copyDirectory($sourceDir, $targetDir);
            $io->success('Assets published successfully!');
        } else {
            $io->warning('No assets found to publish.');
        }

        return Command::SUCCESS;
    }

    private function copyDirectory(string $source, string $target): void
    {
        if (!is_dir($target)) {
            mkdir($target, 0755, true);
        }

        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($source, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );

        foreach ($iterator as $item) {
            $targetPath = $target . DIRECTORY_SEPARATOR . $iterator->getSubPathName();
            
            if ($item->isDir()) {
                if (!is_dir($targetPath)) {
                    mkdir($targetPath, 0755, true);
                }
            } else {
                copy($item->getPathname(), $targetPath);
            }
        }
    }
}

/**
 * Version Command
 */
class VersionCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('version')
            ->setDescription('Show AdminKit version');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);
        $version = function_exists('adminkit_version') ? adminkit_version() : '1.0.4';
        
        $io->title('AdminKit Version Information');
        $io->text("AdminKit version: {$version}");
        $io->text("PHP version: " . PHP_VERSION);
        $io->text("Symfony Console version: " . Application::VERSION);
        
        return Command::SUCCESS;
    }
}

// Create and run application
$application = new Application('AdminKit', '1.0.4');

// Installation & Management
$application->add(new InstallCommand());
$application->add(new UpdateCommand());
$application->add(new VersionCommand());

// Environment Management
$application->add(new EnvCopyCommand());
$application->add(new EnvCheckCommand());

// Docker Management
$application->add(new DockerUpCommand());
$application->add(new DockerDownCommand());

// User Management
$application->add(new UserCreateCommand());

// Database
$application->add(new MigrateCommand());

// Development
$application->add(new ServeCommand());

// Queue
$application->add(new QueueWorkCommand());

// Cache
$application->add(new CacheClearCommand());

// Publishing
$application->add(new PublishAssetsCommand());

$application->run();
